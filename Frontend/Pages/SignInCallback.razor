@page "/signin-callback"
@using RateMyProduction.Frontend.Services
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Authorization
@inject ILocalStorageService Storage
@inject HttpClient Http
@inject NavigationManager Nav
@inject ILogger<SignInCallback> Logger
@inject AuthenticationStateProvider AuthProvider

<div class="d-flex flex-column align-items-center justify-content-center" style="height: 70vh;">
    <div class="spinner-border text-primary" role="status" style="width: 3rem; height: 3rem;">
        <span class="visually-hidden">Loading...</span>
    </div>
    <h3 class="mt-4">Completing secure sign-in...</h3>
    <p class="text-muted">Verifying your credentials with the server</p>
</div>

@code {
    [SupplyParameterFromQuery(Name = "tokenId")]
    public string? TokenId { get; set; }

    protected override async Task OnInitializedAsync()
    {
        // 1. Safety Check: Ensure we actually have a token ID from the URL
        if (string.IsNullOrEmpty(TokenId))
        {
            Logger.LogWarning("SignInCallback reached without a tokenId.");
            Nav.NavigateTo("/login");
            return;
        }

        try
        {
            // 2. Exchange the temporary tokenId for real JWT Access/Refresh tokens
            // This calls your AuthController on port 7066
            var response = await Http.PostAsJsonAsync("api/auth/exchange-token", new { tokenId = TokenId });

            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadFromJsonAsync<TokenResponse>();

                if (result != null)
                {
                    // 3. Persist the data so the user stays logged in on refresh
                    await Storage.SetItemAsync("accessToken", result.AccessToken);
                    await Storage.SetItemAsync("refreshToken", result.RefreshToken);
                    await Storage.SetItemAsync("username", result.Username);

                    // 4. Update the UI "Brain" (AuthenticationStateProvider)
                    // We cast to our custom class to access the Notify method
                    var customStateProvider = (ApiAuthenticationStateProvider)AuthProvider;
                    customStateProvider.NotifyUserAuthentication(result.Username);

                    Logger.LogInformation("Login successful for {User}. Redirecting...", result.Username);

                    // 5. Final Move: Go to your protected main page
                    Nav.NavigateTo("/");
                }
            }
            else
            {
                var errorBody = await response.Content.ReadAsStringAsync();
                Logger.LogError("Token exchange failed. Status: {StatusCode}, Error: {Error}", response.StatusCode, errorBody);
                Nav.NavigateTo("/login?error=auth_failed");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Critical error during the sign-in callback process.");
            Nav.NavigateTo("/error");
        }
    }

    // Helper class to map the JSON response from your API
    private class TokenResponse
    {
        public string AccessToken { get; set; } = string.Empty;
        public string RefreshToken { get; set; } = string.Empty;
        public string Username { get; set; } = string.Empty;
    }
}